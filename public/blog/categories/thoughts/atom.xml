<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Thoughts | sap1ens blog]]></title>
  <link href="http://sap1ens.com/blog/categories/thoughts/atom.xml" rel="self"/>
  <link href="http://sap1ens.com/"/>
  <updated>2016-07-17T19:51:56-07:00</updated>
  <id>http://sap1ens.com/</id>
  <author>
    <name><![CDATA[Yaroslav Tkachenko]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Static typing and refactoring]]></title>
    <link href="http://sap1ens.com/blog/2016/05/22/static-typing-and-refactoring/"/>
    <updated>2016-05-22T20:37:31-07:00</updated>
    <id>http://sap1ens.com/blog/2016/05/22/static-typing-and-refactoring</id>
    <content type="html"><![CDATA[<p>A few months ago I finished a <strong>huge</strong> refactoring of a Java/Scala project. It took 2 weeks and only 2 engineers to actually implement all the changes, make sure it worked and deploy. Surprisingly, deployment was <em>really</em> smooth, we didn’t encounter any major issues.</p>

<p>I think the reason why it went so good was statically typed language + amazing IDE support for that. I can’t imagine doing similar refactoring in Ruby/Python/Node, for example.</p>

<p><img src="/images/posts/refactoring.png"></p>

<!-- more -->


<h2>The task</h2>

<p>Project consists from multiple layers:</p>

<ol>
<li>HTTP API and serialization/deserialization logic (Scala/Jersey)</li>
<li>Service layer (Scala/Java/Spring)</li>
<li>Model (Java/Hibernate/AspectJ)</li>
<li>Database (MySQL)</li>
</ol>


<p>Our goal was to refactor a bunch of model/database fields, mostly renaming (things like <code>TransactionalDocument.TransactionalDocumentId</code> &ndash;> <code>JournalEntry.id</code>). As you can see it mostly affects model and database layers, but the same fields are used in service level as well as API serialization/deserialization logic &ndash; basically the whole system is affected.</p>

<h2>Refactoring</h2>

<p>First of all, we divided all model classes between 2 engineers and started to deal with classes one by one.</p>

<p>Our toolkit included IntelliJ IDEA and some shell automation for applying database schema and changesets.</p>

<p>Process was simple &ndash; rename model field using IntelliJ IDEA refactoring feature, rename database field in a schema file and verify your changes by:</p>

<ul>
<li>compiling the project (minute[s])</li>
<li>recreating database from schema and changesets (seconds)</li>
</ul>


<p>A few words about IntelliJ IDEA: I’ve been using this IDE for years and I’m so thankful to Jetbrains for this amazing piece of tech (and also I’m a little bit proud, since it’s built by smart Russian guys). Because Java and Scala are statically typed languages, IDE is able to trace <em>every single usage of a type or a field</em>, including all layers I mentioned. You just run rename command, confirm all changes in preview, if changeset is large, and apply it in seconds! And you can be absolutely sure that all changes are correct.</p>

<p>One more lesson from this exercise &ndash; it’s always a good idea to NOT expose your model fields directly in API. We have an explicit serialization/deserialization logic in that project and I didn’t have to also refactor front-end app (which is mostly Coffeescript) &ndash; so good! ;)</p>

<p>Also I want to notice that compilation was enough to test changes, I didn’t even need to run the app to check intermediate results. It allowed us to iterate as fast as possible (which was not really fast, because it runs <strong>3</strong> compilers internally: AspectJ, Java and Scala).</p>

<p>We obviously had a huge set of tests (hundreds) + some things could’ve been tested only in runtime (like Spring configuration), but again: you can mostly rely on IDE/compilation to make sure everything works smoothly. Which is an amazing feeling :)</p>

<p>By the way, tests actually helped to discover something that IDE has missed. We use Hibernate and write all queries using JPQL. These queries are represented by simple strings, but IntelliJ IDEA is mostly able to parse those strings and understand actual classes and fields used there. I said mostly, because for some reason sometimes it missed some of the queries and we only could detect those using tests.</p>

<h2>Summary</h2>

<p>So, if you’re planning to work on a big refactoring I advice:</p>

<ul>
<li>Understand the easiest way to verify your changes. If you use a statically typed language, compilation is usually enough, but you should always have tests to cover your main code paths</li>
<li>Make sure you know how to make iteration loop as fast as possible using previous verification step. Refactoring always needs time and it’s important to optimize your workflow</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[About technical leadership]]></title>
    <link href="http://sap1ens.com/blog/2016/04/25/about-technical-leadership/"/>
    <updated>2016-04-25T21:06:16-07:00</updated>
    <id>http://sap1ens.com/blog/2016/04/25/about-technical-leadership</id>
    <content type="html"><![CDATA[<p>Software development teams naturally have leaders. I see two types of leaders: team leads and technical leads.</p>

<p>Team leads care about projects, tasks, velocity and related things and usually have titles like Team Lead, Project Manager or Technical Project Manager. They can be programmers and know how to code, but their main focus is planning projects and organizing processes.</p>

<p>Today I want to talk about technical leads. You’ll probably call them Engineering Lead or Lead Engineer. Their role is not always clear, sometime they can lead a team and participate in the project management activities, but keep the focus on coding and delivering products. Sometimes they can have a specialization on some specific area or domain, like Lead Back-end Engineer or similar. But they have something in common.</p>

<p>Recently I’ve been asked by a coworker who wants to move to the technical leadership &ndash; “what do I need to improve”? I wasn’t ready to answer, because I didn’t have a clear picture what technical leaders do, precisely :) I started to think and reflect more and I think I have pretty good understanding now.</p>

<p>Software engineers have clear goals: making individual contributions and delivering products/features.</p>

<p>Technical leaders care about opposite: empowering a <em>team</em>, making sure a <em>team</em> uses best practices like pair programming or writes good tests, invests into documentation and tooling, cares a lot about reliable architecture and clear codebase, you name it. Goal of a technical lead is to make sure that everyone in a team contributes as much as they can and constantly push efficiency and quality of work for the whole team forward.</p>

<p>Again, it’s not about being “the guy”, it’s about thinking of team contributions more than yours.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Complexity and software]]></title>
    <link href="http://sap1ens.com/blog/2016/02/21/complexity-and-software/"/>
    <updated>2016-02-21T11:58:28-08:00</updated>
    <id>http://sap1ens.com/blog/2016/02/21/complexity-and-software</id>
    <content type="html"><![CDATA[<p>Software engineers like to discuss different aspects of their craft: elegant solutions, performance benchmarks, semantics of programming languages, the shortest webapp implementation with a favourite framework, etc. We like to argue why language X is better than Y and why framework A is faster/simpler/better to use than B.</p>

<p>Something that we don’t usually discuss is complexity. The important thing to realize: we can’t remove it. We can try to hide it, yes. But any relatively big system has complexity in some form, on some level.</p>

<p>As an example, let’s take a look at popular Sinatra-inspired web frameworks: Flask, Express, etc. It’s <strong>really</strong> simple to create a small webapp or RESTful API. Very simple. So simple that the whole implementation fits on one screen. But still, they hide complexity. Try to run them on multi-core and multi-node cluster efficiently and reliably. That should be relatively “easy” to do, until your application has a state or you discover that not everything is thread-safe. Fun stuff. Distributed systems are hard.</p>

<p>Ok, how about the other side now. Toolkits like Erlang/OTP or Scala/Akka are considered to be complex and suited for building distributed systems. They move complexity to a different edge, so bootstrapping takes much more time, but “hard” problems are actually easier to solve. <a href="http://doc.akka.io/docs/akka/2.4.2/scala/cluster-singleton.html">Cluster Singleton</a> or <a href="http://doc.akka.io/docs/akka/2.4.2/scala/cluster-sharding.html">Cluster Sharding</a>? Yep, it’s there!</p>

<p>The same concept applies to programming languages. Everything has pros and cons. Complexity should always be an additional dimension that we should take into consideration, discuss it and plan accordingly.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[State &#8733; 1 / Scale]]></title>
    <link href="http://sap1ens.com/blog/2014/12/06/state-1-slash-scale/"/>
    <updated>2014-12-06T15:53:48-08:00</updated>
    <id>http://sap1ens.com/blog/2014/12/06/state-1-slash-scale</id>
    <content type="html"><![CDATA[<p>From <a href="http://www.jamesward.com/2014/12/03/java-doesnt-suck-youre-just-using-it-wrong">Java Doesn’t Suck – You’re Just Using it Wrong</a>:</p>

<blockquote><p>Sticky sessions and server state are usually one of the best ways to kill your performance and resilience. Session state (in the traditional Servlet sense) makes it really hard to do Continuous Delivery and scale horizontally. If you want a session cache use a real cache system – something that was designed to deal with multi-node use and failure. e.g. Memcache, ehcache, etc. In-memory caches are fast but hard to invalidate in multi-node environments and are not durable across restarts – they have their place, like calculated / derived properties where invalidation and recalculation are easy.</p>

<p>Web apps should move state to the edges. UI-related state should live on the client (e.g. cookies, local storage, and in-memory) and in external data stores (e.g. SQL/NoSQL databases, Memcache stores, and distributed cache clusters). Keep those REST services 100% stateless or else the state monster will literally eat you in your sleep.</p></blockquote>

<p>It&rsquo;s easy to follow the rule, but if you didn&rsquo;t&hellip; :&ndash;/</p>

<p>Server state is very hard to fix, it requires massive refactoring and additional tools sometimes. Personally, I&rsquo;ve realized that it&rsquo;ll be my rule #1: avoid state as much as you can.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[New blog: version unknown]]></title>
    <link href="http://sap1ens.com/blog/2013/11/24/new-blog-version-unknown/"/>
    <updated>2013-11-24T20:03:28-08:00</updated>
    <id>http://sap1ens.com/blog/2013/11/24/new-blog-version-unknown</id>
    <content type="html"><![CDATA[<p>It looks like this is my new blog. I&rsquo;ve tried to keep a few blogs before, but because of different reasons they all are closed.
Right now it feels right for me to keep my writings somewhere. Let&rsquo;s try one more time.</p>
]]></content>
  </entry>
  
</feed>
